//	Библиотека для работы с блоками перистальтических насосов iarduino по шине Modbus:
//	Блок на 2 перистальтических насоса RS485/Modbus (KPHM100):    https://iarduino.ru/shop/Expansion-payments/blok-na-2-peristalticheskih-nasosa-rs485---modbus-kphm100.html
//	Блок на 2 перистальтических насоса RS485/Modbus (NKP-DC-S08): https://iarduino.ru/shop/Expansion-payments/peristaltic-2-pumps-Modbus-RS485.html
//	Блок на 3 перистальтических насоса RS485/Modbus (KPHM100):    https://iarduino.ru/shop/Expansion-payments/blok-na-3-peristalticheskih-nasosa-rs485---modbus-kphm100.html
//	Блок на 3 перистальтических насоса RS485/Modbus (NKP-DC-S08): https://iarduino.ru/shop/Expansion-payments/peristaltic-3-pumps-Modbus-RS485.html
//  Версия: 1.0.5
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/file/593.html
//  Подробное описание функции бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/page/peristaltic-pumps-Modbus-RS485/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru
//	Дополнительно требуется установить библиотеку реализации протокола Modbus RTU/ASCII на шине UART->RS485: https://iarduino.ru/file/591.html

#ifndef iarduino_MB_Pump_h
#define iarduino_MB_Pump_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

#include <iarduino_Modbus.h>																	//	Подключаем файл iarduino_Modbus.h - для работы по протоколу Modbus.
																								//
#define DEF_MODEL_PUMP1		4																	//	Идентификатор модели - константа.
#define DEF_MODEL_PUMP2		2																	//	Идентификатор модели - константа.
#define DEF_MODEL_PUMP3		3																	//	Идентификатор модели - константа.
																								//
#define PUMP_ALL			0																	//	Аргумент функций управления насосами - все насосы.
#define PUMP_A				1																	//	Аргумент функций управления насосами - насос A.
#define PUMP_B				2																	//	Аргумент функций управления насосами - насос B.
#define PUMP_C				3																	//	Аргумент функций управления насосами - насос C.
																								//
#define PUMP_SENSOR_ALL		0																	//	Аргумент функции digitalRead() - прочитать состояния всех датчиков уровня житскости. Функция вернёт байт, шесть младших битов которого отражают состояния датчиков.
#define PUMP_SENSOR_MIN_A	1																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MIN A.
#define PUMP_SENSOR_MID_A	2																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MID A.
#define PUMP_SENSOR_MIN_B	3																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MIN B.
#define PUMP_SENSOR_MID_B	4																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MID B.
#define PUMP_SENSOR_MIN_C	5																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MIN C.
#define PUMP_SENSOR_MID_C	6																	//	Аргумент функции digitalRead() - прочитать состояние датчика уровня житскости MID C.
																								//
class iarduino_MB_Pump{																			//
	public:																						//
	/**	Конструктор класса **/																	//
		iarduino_MB_Pump				(ModbusClient&	);										//	Объявляем конструктор класса.											Параметры: ссылка на объект работы по протоколу Modbus.
	/**	Пользовательские функции **/															//
		bool			begin			(uint8_t id=0	);										//	Объявляем  функцию инициализации насосов.								Параметры функции: ID насосов. Функция возвращает результат инициализации: true-успех / false-провал.
		bool			reset			(void			);										//	Объявляем  функцию перезагрузки насосов.								Параметры функции: нет. Функция возвращает результат перезагрузки: true-успех / false-провал.
		bool			changeID		(uint8_t new_id	);										//	Объявляем  функцию смены ID насосов (выполняется >120мс).				Параметры функции: новый ID. Функция возвращает результат смены ID: true-успех / false-провал.
		bool			setSpeedMB		(uint32_t speed	);										//	Объявляем  функцию смены скорости передачи данных.						Параметры функции: новая скорость. Функция возвращает результат смены скорости: true-успех / false-провал. Скорость необходимо подтвердить в течении 2 секунд.
		bool			ackSpeedMB		(void			);										//	Объявляем  функцию подтверждения скорости (выполняется >50мс).			Параметры функции: нет. Функция возвращает результат подтверждения скорости: true-успех / false-провал. 
		bool			setTypeMB		(uint8_t type	);										//	Объявляем  функцию смены типа протокола Modbus.							Параметры функции: MODBUS_RTU/MODBUS_ASCII. Функция возвращает результат смены типа протокола Modbus: true-успех / false-провал. Тип необходимо подтвердить в течении 2 секунд.
		bool			ackTypeMB		(void			);										//	Объявляем  функцию подтверждения типа протокола (выполняется >50мс).	Параметры функции: нет. Функция возвращает результат подтверждения типа протокола Modbus: true-успех / false-провал. 
		bool			writeFlash		(uint16_t data	);										//	Объявляем  функцию записи пользовательского значения в Flash память.	Параметры функции: целое беззнаковое число от 0 до 65535. Функция возвращает результат записи: true-успех / false-провал. 
		int32_t			readFlash		(void			);										//	Объявляем  функцию чтения пользовательского значения из Flash памяти.	Параметры функции: нет. Функция возвращает прочитанное значение, или -1 при провале чтения.
		uint8_t			getID			(void			){ return valID;	}					//	Определяем функцию получения текущего ID (адрес модуля на шине).		Параметры функции: нет. Функция возвращает текущий ID насосов, или 0 если модуль не определён.
		uint8_t			getVersion		(void			){ return valVers;	}					//	Определяем функцию получения текущей версии прошивки насосов.			Параметры функции: нет. Функция возвращает версию прошивки насосов, или 0 если модуль не определён.
		float			getPWR			(void			);										//	Объявляем  функцию получения напряжения питания.						Параметры функции: нет. Функция возвращает напряжение питания в Вольтах, или -1 при провале чтения.
		bool			setIDLED		(bool on		);										//	Объявляем  функцию смены состояния светодиода обнаружения устройства.	Параметры функции: состояние светодиода true/false. Функция возвращает результат изменения состояния: true-успех / false-провал.
		int32_t			getErr			(void			);										//	Объявляем  функцию получения флагов ошибок из регистра диагностики.		Параметры функции: нет. Функция возвращает значение регистра диагностики, каждый из 16 бит которого является флагом ошибки, или -1 при провале чтения.
		uint8_t			getSumPump		(void			){ return sumPUMP;	}					//	Определяем функцию получения количества насосов у модуля.				Параметры функции: нет. Функция возвращает количество насосов, или 0 если модуль не определён.
		bool			setFrequency	(uint8_t pump, uint16_t freq, uint16_t=0, uint16_t=0);	//	Объявляем  функцию смены частоты ШИМ насосов.							Параметры функции: PUMP_X/PUMP_ALL, частота в Гц (1-10000). Функция возвращает результат применения частоты: true-успех / false-провал.
		int32_t			getFrequency	(uint8_t pump										);	//	Объявляем  функцию чтения частоты ШИМ насоса.							Параметры функции: PUMP_X. Функция возвращает частоту в Гц (1-10000), или -1 при провале чтения частоты.
		bool			setPower		(uint8_t pump, uint8_t  pwm , uint8_t=0 , uint8_t=0	);	//	Объявляем  функцию смены мощности насосов (ШИМ).						Параметры функции: PUMP_X/PUMP_ALL, мощность (1-255). Функция возвращает результат применения мощности: true-успех / false-провал.
		int16_t			getPower		(uint8_t pump										);	//	Объявляем  функцию чтения мощности насоса (ШИМ).						Параметры функции: PUMP_X. Функция возвращает мощность насоса (1-255), или -1 при провале чтения мощности.
		bool			setState		(uint8_t pump, bool     on  , bool=0    , bool=0	);	//	Объявляем  функцию смены состояния насосов.								Параметры функции: PUMP_X/PUMP_ALL, состояния true/false. Функция возвращает результат изменения состояний: true-успех / false-провал.
		int8_t			getState		(uint8_t pump										);	//	Объявляем  функцию чтения состояния насосов.							Параметры функции: PUMP_X/PUMP_ALL. Функция возвращает состояние насоса: 1-вкл / 0-выкл, байт битов если читаются все насосы, или -1 при провале чтения состояния насоса.
		bool			setTimeOn		(uint8_t pump, float    sec , float=0   , float=0	);	//	Объявляем  функцию включения насосов на время.							Параметры функции: PUMP_X/PUMP_ALL, время в секундах (0,0-6553,5). Функция возвращает результат применения времени: true-успех / false-провал.
		float			getTimeOn		(uint8_t pump										);	//	Объявляем  функцию чтения оставшегося времени работы насоса.			Параметры функции: PUMP_X. Функция возвращает оставшееся время работы насоса в секундах (0,0-6553,5), или -1 при провале чтения времени.
		bool			setPomp12V		(uint8_t pump, bool     on  , bool=0    , bool=0	);	//	Объявляем  функцию коррекции питания для насосов до 12В.				Параметры функции: PUMP_X/PUMP_ALL, коррекция true/false. Функция возвращает результат изменения состояний: true-успех / false-провал.
		int8_t			getPomp12V		(uint8_t pump										);	//	Объявляем  функцию чтения наличия коррекции питания насосов до 12В.		Параметры функции: PUMP_X/PUMP_ALL. Функция возвращает флаг наличия коррекции питания насоса: true-вкл / false-выкл, байт флагов если читаются все насосы, или -1 при провале чтения коррекции насоса.
		int8_t			digitalRead		(uint8_t sens	);										//	Объявляем  функцию чтения состояния датчиков уровней жидкости.			Параметры функции: один из вариантов PUMP_SENSOR_XXX_X. Функция возвращает уровень датчика 0/1, байт битов если читаются все датчики, или -1 при провале чтения уровня датчика.
		bool			enableWDT		(uint16_t ms	);										//	Объявляем  функцию разрешения работы   сторожевого таймера насосов.		Параметры функции: время в миллисекундах от 1 до 65535. Функция возвращает результат включения сторожевого таймера: true-успех / false-провал.
		bool			disableWDT		(void	 		);										//	Объявляем  функцию запрета    работы   сторожевого таймера насосов.		Параметры функции: нет. Функция возвращает результат отключения сторожевого таймера: true-успех / false-провал.
		bool			resetWDT		(void			);										//	Объявляем  функцию сброса (перезапуск) сторожевого таймера насосов.		Параметры функции: нет. Функция возвращает результат сброса сторожевого таймера: true-успех / false-провал.
		int8_t			getStateWDT		(void			);										//	Объявляем  функцию чтения состояния сторожевого таймера насосов.		Параметры функции: нет. Функция возвращает состояние сторожевого таймера: 1-включён, 0-выключён, или -1 при провале чтения состояния сторожевого таймера.
																								//	
	private:																					//	
	/**	Внутренние переменные **/																//
		ModbusClient*	objModbus;																//	Объявляем  указатель на объект работы по протоколу Modbus.				Указатель получит адрес объекта в конструкторе класса.
		uint8_t			valID			= 0;													//	Определяем переменную для хранения ID насосов который был проверен.
		uint8_t			valVers			= 0;													//	Определяем переменную для хранения версии прошивки насосов.
		uint8_t			sumPUMP			= 0;													//	Определяем переменную для хранения количества насосов у модуля.
		uint16_t		valWDT;																	//	Объявляем  переменную для хранения времени сторожевого таймера в мс.	Определяется в enableWDT(), используется в resetWDT().
		uint8_t			maxRW			= 5;													//	Определяем максимальное количество попыток чтения/записи.
	/**	Внутренние функции **/																	//
		int8_t			MB_readDO		(uint16_t reg							);				//	Дублер функции objModbus.coilRead();             Чтение одного регистра DO, из  модуля valID, maxRW попыток. Параметры функции: адрес регистра. Функция возвращает прочитанное значение (0/1), или -1 при неудаче.
		int8_t			MB_readDI		(uint16_t reg							);				//	Дублер функции objModbus.discreteInputRead();    Чтение одного регистра DI, из  модуля valID, maxRW попыток. Параметры функции: адрес регистра. Функция возвращает прочитанное значение (0/1), или -1 при неудаче.
		int32_t			MB_readAO		(uint16_t reg							);				//	Дублер функции objModbus.holdingRegisterRead();  Чтение одного регистра AO, из  модуля valID, maxRW попыток. Параметры функции: адрес регистра. Функция возвращает прочитанное значение (0...65535), или -1 при неудаче.
		int32_t			MB_readAI		(uint16_t reg							);				//	Дублер функции objModbus.inputRegisterRead();    Чтение одного регистра AI, из  модуля valID, maxRW попыток. Параметры функции: адрес регистра. Функция возвращает прочитанное значение (0...65535), или -1 при неудаче.
		uint16_t		MB_requestFrom	(uint8_t  type, uint16_t reg, uint16_t n);				//	Дублер функции objModbus.requestFrom();          Чтение нескольк регистров, из  модуля valID, maxRW попыток. Параметры функции: тип регистра (COILS/DISCRETE_INPUTS/HOLDING_REGISTERS/INPUT_REGISTERS), адрес первого регистра, количество регистров. Функция возвращает количество прочитанных значений, или 0 при неудаче.
		uint8_t			MB_getInfo		(uint8_t  id							);				//	Дублер функции objModbus.getInfo();              Чтение информации о устройстве модуля id   , maxRW попыток. Параметры функции: id модуля. Функция возвращает количество байт данных об устройстве, доступных для чтения функцией read() и available().
		int32_t			MB_diagnostic	(uint16_t func, uint16_t data=0			);				//	Дублер функции objModbus.diagnostic();           Выполнение команды диагностики модуля valID, maxRW попыток. Параметры функции: номер функции диагностики, данные. Функция возвращает данные результата выполнения функции диагностики, или -1 при неудаче.
		bool			MB_changeID		(uint8_t  newID							);				//	Дублер функции objModbus.changeID();             Сохранение нового ID     , для модуля valID, maxRW попыток. Параметры функции: новый id модуля. Функция возвращает результат сохранения адреса (0/1).
		bool			MB_writeDO		(uint16_t reg, bool val					);				//	Дублер функции objModbus.coilWrite();            Запись в один регистр  DO, для модуля valID, maxRW попыток. Параметры функции: адрес регистра, значение (0/1). Функция возвращает 1 при успехе, 0 при неудаче.
		bool			MB_writeAO		(uint16_t reg, uint16_t val				);				//	Дублер функции objModbus.holdingRegisterWrite(); Запись в один регистр  AO, для модуля valID, maxRW попыток. Параметры функции: адрес регистра, значение (0...65535). Функция возвращает 1 при успехе, 0 при неудаче.
};

#endif